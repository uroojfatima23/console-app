# Research Summary: FastAPI, SQLModel, and Authentication

## 1. FastAPI + SQLModel Best Practices

### Models and Database Connection
- **Models**: Inherit from `SQLModel` with `table=True` for database tables. Use `Optional` and `Field(default=None)` for nullable columns.
- **Async Engine**:
  ```python
  from sqlmodel import create_engine
  from sqlalchemy.ext.asyncio import create_async_engine

  # For async, use create_async_engine from sqlalchemy.ext.asyncio
  # Note: SQLModel's create_engine is synchronous wrapper around SQLAlchemy's
  DATABASE_URL = "postgresql+asyncpg://user:password@host/db"
  engine = create_async_engine(DATABASE_URL, echo=True, future=True)
  ```
- **Initialization**: Create tables on startup using `await conn.run_sync(SQLModel.metadata.create_all)` within a startup event or lifespan context manager.

### Dependency Injection
- **Session Dependency**: Use an async generator with `AsyncSession`.
  ```python
  from sqlmodel.ext.asyncio.session import AsyncSession
  from sqlalchemy.orm import sessionmaker

  async def get_session() -> AsyncSession:
      async_session = sessionmaker(
          engine, class_=AsyncSession, expire_on_commit=False
      )
      async with async_session() as session:
          yield session

  SessionDep = Annotated[AsyncSession, Depends(get_session)]
  ```

## 2. Authentication with JWT

### Modern Pattern
- **OAuth2PasswordBearer**: Standard FastAPI security utility for extracting tokens.
- **Flow**:
  1. Login endpoint validates credentials and returns JWT.
  2. `get_current_user` dependency uses `OAuth2PasswordBearer` to extract token.
  3. Decode JWT with `jwt.decode` (PyJWT or python-jose).
  4. Validate claims (expiration, subject).
  5. Fetch user from DB (optional but recommended for strictly secure apps) or construct user object from claims.

### Code Pattern
```python
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)], session: SessionDep):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id = payload.get("sub")
        if user_id is None:
            raise HTTPException(...)
    except JWTError:
        raise HTTPException(...)

    user = await session.get(User, user_id)
    if not user:
        raise HTTPException(...)
    return user
```

## 3. Project Structure for Single File
Even within a single `main.py`, separation of concerns can be achieved:
- **Grouping**: Use standard functions to group logical components.
- **Routers**: You can define `APIRouter` instances in the same file and include them, but for a true single-file app, just using `@app.get` / `@app.post` with tags is cleaner.
- **Ordering**:
  1. Imports
  2. Configuration / Envs
  3. Database Setup (Engine, Models)
  4. Dependencies (Session, Auth)
  5. API Routes (grouped by tags)
  6. Startup Events (Lifespan)

## 4. UV Usage
- **Initialization**: `uv init <project_name>` creates a new project with `pyproject.toml`.
- **Adding Dependencies**: `uv add <package>` adds to `pyproject.toml` and installs.
- **Running**: `uv run main.py` or `uv run uvicorn main:app --reload`.

## 5. Better Auth Note
- The original request mentioned "Better Auth". While standard JWT is common, if "Better Auth" refers to the specific library `better-auth` (often associated with Next.js/Node ecosystems), we might need to verify Python compatibility or strict adherence to the JWT standards it produces. For a pure Python FastAPI backend, standard JWT implementation handling tokens generated by the frontend (or a dedicated auth service) is the robust path. We will assume standard JWT validation on the backend.
